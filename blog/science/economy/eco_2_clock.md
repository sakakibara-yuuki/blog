---
title: "経済: #2 Data Analysis of Tick Data"
author: "sakakibara"
description: "上手くいかないことがありましたが、コミュニティに質問して助けてもらいました！"
heroImage: "/science/science.jpg"
pubDate: 2024-05-22
tags: ["economy", "経済", "FIX", "BWIC"]
---

## tick
トーレディングのデータに限らず取引のデータは通常, 表形式に成っていることが多い。
そのカラムは取引Noをキーとして種類、数量、価格、日時などが含まれる。
このような表形式のデータを金融ではバーと呼ぶ。

ここでbarとは一定の基準で区切られた表形式のデータであり、データ一点のことではない。データの集まり(表)のことである。

研究で使われるバーは大分して２つ。一つは標準バー方式、もう一つが情報ドリブン方式である。後者の法を使用している実務家は多いと聞く。
以下にこれからの議論の重要な点をまとめる。

- 情報は一定のエントロピー速度で市場に届くわけではない。
- 時系列的な間隔でデータをサンプリングすることは、個々の観測者の情報コンテンツが一定からほど遠いことを意味する。
- より良いアプローチは、交換される情報量に従属する過程として観測データをサンプリングすることである。

## 標準バー方式(Forming Bars)
当然だが、機械学習の多くの技術ではデータをそのままNNなどに突っ込めば良いということは無く、正規化や標準化を行ってから機械学習などにかけることが多い。
標準バー方式はどのようにデータをサンプリングするかを決めるバーのサンプリング方式のことである。
目的とするところは、データがiidのノイズが乗ったデータとなるように時系列データを適切にサンプリングし、解析(計量時系列分析なり機械学習なり)をしやすくすることである。
### time-bar
生のデータは取引No毎に送られてくることが多い。
time-bar方式は1分毎に1回情報をサンプリングする方法である。
これはごく自然な方法であり、最も人気があり、実際に研究論文などでもこの方法が最も多く使われているだろう。
しかし、精度の良い解析のためにはこの方法は避けるべきだ。
というのも、取引が活発な時間帯とそうでない時間帯を同じように扱ってしまうからである。
例えば、日本の株式市場の場合、取引が活発な時間帯は朝のオープンと昼の昼休み明けであるが、ここでの取引とそれ以外の時間帯の取引では出来高が異なる。
つまり、取引の活発な時間帯は過小にサンプリングし、閑散な時間帯は過大にサンプリングしてしまう。
さらにそれがHFTによって非常に激しく成っている場合、この方法は適切ではない。

メリット:
- 実装が簡単

デメリット:
- 系列相関(観測値が前後の観測値とどの程度関連しているか)
- 分散不均一性(時間とともに分散が一定ではなくなること)
- 非正規分布リターン(極端な下落、上昇などが予想以上に存在すること)

という功罪をもたらす。
など[Flow Toxicity and liquidity in a high-frequency world]()にも関連している。

### ticks-bar
100回の取引毎にデータを区切ったらどうだろうか？
あまりにも単純な考えだが、これがtick-barである。
じつはこの方法はtime-barよりも優れた統計的性質を持っている。
[On The Distribution of Stock Price Difference]()が発表されたのは1967年のことだ。
考えて見れば当然といえば当然だ。
time-barは取引毎から見たら相当不均一なデータをサンプリングしていると言えるが、ticks-barはそれよりかは少しだけマシなのである。
<!-- ticks-barでは一定の取引数における価格変動はガウス分布に従う。 -->
<!-- 一定の時間内の価格変動は、分散無限大の安定パレート分布に従う。 -->
### volume-bar
ではticks-barが最適かというとそうではない。
分割注文があるとtickに恣意性が含まれてしまうのだ。
例えば、10株の売り注文が1つあると、これは$1$ ticksとしてカウントされるが、1株の売り注文を10個あると、これは$10$ticksとしてカウントされるのだ。
取引所や証券会社の売買マッチングエンジンによってはこのような分割注文が多く発生することがある。
このような恣意性を排除して見たいものをクリアにする必要がある。
volume-barは一定の出来高毎に表をサンプリングする方法である。
実はvolume-barによるリターンはtick-barによるサンプリングよりもiid従ったリターン分布になることが知られている。

### dollar-bar
dollar-barは一定の金額毎にサンプリングする方法である。
これはvolume-barと似たような発想だが、volume-barよりも時間に対して一日あたりの平均バー数が一定になるというメリットがある。

## 情報ドリブン方式
情報ドリブン方式は標準バー方式とは異なり、新たなデータが来るたびに情報が含まれているかを検知し、より高頻度にサンプリングする方法である。つまり、動的にバーのサイズを変更する方法である。

### tirck-imbalance-bar
tick系列を$\set{(p_t, v_t)}(t=1,\ldots, T)$とする。$p_t$はtick$t$の価格であり、$v_t$はティック$t$の出来高(取引ドル)とする。
ここで、次のような系列$\set{b_t}t=1,\ldots, T$を定義する。
$$
b_t =
\begin{cases}
 1 & \text{if} v_{t-1} < v_t \\
 b_{t-1} & \text{if} v_{t-1} = v_t \\
-1 & \text{if} v_{t-1} > v_t
\end{cases}
$$
ここで$b_t \in \set{-1, 1}$であり、この累積が一定値を超えたらサンプリングするという方法である。  
$T$までの累積をtick-imbalanceとし、以下のように定義する。
$$
\theta_T = \sum_{t=1}^T b_t
$$
ここで注意すべきはTはバーのサイズであり、確率変数である。
当然$\theta_T$も確率変数である。

現状を整理する。  
まず、取引一つずつの情報が送られてくる。
この取引一つの情報をtickと呼ぶ。
このtick全体(ticks)を適切にサンプリングするためにサンプリングの幅$T$を決めようと思う。
つまりticksを$\set{1,\ldots, T_0}, \set{1, \ldots, T_1}, \ldots, \set{1, \ldots, T_n}$のように分割する幅$T$を決定することを取り組む。  

$\theta_T$は$T$を決めれば当然求まる。が、そもそも$T$を決める道具として$\theta_T$を使おうとしていたことを思い返してほしい。  
そこで、$\theta_T$の期待値を計算する。
$$
\begin{aligned}
\mathbb{E}[\theta_T] &= \mathbb{E}[{T\frac{\sum_{t=1}^Tb_t}{T}}] \\
                     &= \mathbb{E}[T](\frac{\text{num of}(b=1)}{T} - \frac{\text{num of}(b=-1)}{T}) \\
                     &= \mathbb{E}[T](P(b_t=1) - P(b_t=-1))
\end{aligned}
$$
ここで、計算に使用した系列$\set{b_t}$は過去の値を使う。
より、具体的には$\mathbb{E}[T]$は前のバーまでの指数加重移動平均、
$P(b_t=1)-P(b_t=-1)$は前のバーまでのtickの$b_t$を使う。
そして、現在のtick-imbalance-barを以下のように定める。
$$
T^* = \arg\min_T\set{|\theta_T|\geq|\mathbb{E}[T](P(b_t=1) - P(b_t=-1))|}
$$
つまり、$\theta_T$の期待値よりも大きい値が出たらサンプリングするという方法である。

### volume/dollar-imbalance-bar
volume/dollar-imbalance-barはtick-imbalance-barと同様に考えることができる。
imbalanceを以下のように定義する。
$$
\theta_T = \sum_{t=1}^T b_tv_t
$$
ここで、$v_t$は出来高ならばvolume-imbalance, 取引ドルならばdollar-imbalanceとなる。
以降、$\sum_{t\in\{t|b_t=1\}}$を$\sum_{t|b_t=1}$と表記する。

その期待値は
$$
\begin{aligned}
\mathbb{E}[\theta_T] &= \mathbb{E}[T\frac{\sum_{t=1}^{T}b_tv_t}{T}] \\
                     &= \mathbb{E}[T\frac{\sum_{t|b_t=1}v_t - \sum_{t|b_t=-1}v_t}{T}] \\
                     &= \mathbb{E}[T(\frac{\sum_{t|b_t=1}v_t}{T} - \frac{\sum_{t|b_t=-1}v_t}{T})] \\
                     &= \mathbb{E}[T(P(b_t=1)E[v_t|b_t=1] - P(b_t=-1)E[v_t|b_t=-1])] \\
                     &= \mathbb{E}[T](P(b_t=1)E[v_t|b_t=1] - P(b_t=-1)E[v_t|b_t=-1])
\end{aligned}
$$
ここで、簡略化のために$v^+=P(b_t=1)E[v_t|b_t=1]$とし,  
$v^-=P(b_t=-1)E[v_t|b_t=-1]$とすると
$$
\mathbb{E}[\theta_T] = \mathbb{E}[T](v^+ - v^-)
$$
のように簡略化して表すことができる。
そして、tick-barと同様に以下に考えられる。

$$
T^* = \arg\min_T\set{|\theta_T|\geq|\mathbb{E}[T](v^+ - v^-)|}
$$

### Tick Run bar
tick-imbalance-bar, volume/dollar-imbalance-barはtickの情報を使って注文の不均衡を捉える方法である。
ところで、大口トレーダーは注文版を一気に一掃したり、親注文を複数の子注文に分割して取引することがある。
このような注文は$\set{b_t}_ {t=1,\ldots, T}$に同じ値の繰り返しという形で痕跡を残す。
前まではimbalanceを使っていたが、ここではその痕跡をrunと呼ぶ。
これを利用できないだろうか。例えば、
出来高全体のうち*買い*, *売り* のみの連続性を監視し、その累積が既定値を超えていたらサンプリングするという方法である。

$$
\theta_T = \max\big\set{\sum_{t|b_t=1} b_t,\ -\sum_{t|b_t=-1}b_t}
$$
次に、これまでと同じようにimbalanceの期待値を
$$
\mathbb{E}[\theta_T] = \mathbb{E}[T]\max\set{P(b_t=1),\ P(b_t=-1)}
$$
とする。
これにより、barのサイズを決定することができる。
$$
T^* = \arg\min_T\set{|\theta_T|\geq|\mathbb{E}[T]\max\set{P(b_t=1),\ P(b_t=-1)}
|}
$$
ここで、$\theta_T$が期待値よりも大きい期待値が出たらサンプリングするという方法である。
このrunの定義では買いと売りの最長連続系列のみを測定し、売りと買いの打ち消しなしでカウントする。

### Volume/Dollar Run bar
volume-run-bar, dollar-run-barはtick-run-barと同様の考えを出来高や売買代金に対して適応したものである。
runは以下のように定義できる。
$$
\theta_T = \max\big\set{\sum_{t|b_t=1} b_tv_t,\ -\sum_{t|b_t=-1}b_tv_t}
$$
そして、期待値は
$$
\mathbb{E}[\theta_T] = \mathbb{E}[T]\max\set{P(b_t=1)\mathbb{E}[v_t|b_t=1],\ P(b_t=-1)\mathbb{E}[v_t|b_t=-1]}
$$
そして、runによるbarのサイズは
$$
T^* = \arg\min_T\set{|\theta_T|\geq|
                    \mathbb{E}[T]\max\set{P(b_t=1)\mathbb{E}[v_t|b_t=1],\ P(b_t=-1)\mathbb{E}[v_t|b_t=-1]}
|}
$$
となる。

### ETFトリック
先物スプレッド(spread of futures)を売買する戦略を発展させるとしよう。ここで、いくつか厄介な点が発生する。
1. スプレッドは時間経過とともに変化する重みのベクトル(tuple)によって特徴づけられる。すると、価格が変化しなくても、スプレッド自体が収束する可能性がある。結果、その系列を取引するモデルはPnLがそのウェイトによって生じたものであると誤解することになる。
1. スプレッド自体が負の値をとることになる。たいていのモデルは負の入力を想定していない。
1. 取引時間は全ての構成銘柄で正確に一致しているわけではない、スプレッドは常に公表された最後の水準で取引可能であるとは限らず(bitaskspreadのリスクあり)、遅延リスクもゼロではない。

この回避策として、ETFトリックがある。
ETFトリックとは1ドルをスプレッドに投資し、その価値を反映するような時系列$\set{K_t}$を作成することである。
言ってしまえば、ETFトリックとは複数の商品データセットを単一のデータセットに変換して、トータルリターンETFのように扱う方法である。
このテクニックは複雑で異なる構成要素を持つ時系列であっても、常に現金のような(有効期限のないキャッシュインストゥルメントのような)商品だけを取引しているとコードが過程できるようにすることができる。
その時系列$\set{K_t}$の変化はPnLの変化を反映し、時系列は厳密に正(株の損益なので最小でも$0$)となり、執行コストを考慮したものである。
この系列はあたかもETFのようにモデル化、シグナル生成、取引に使用される。
前セクションで述べたのように、様々な方法で得られたbarの履歴が与えられたとする。なお、この$bar$では$bar_1, bar_2,\ldots, bar_T$のようにbarの系列が与えられているとする。ここで$T$はbarの数であり、barのサイズではない。

- $o_{i,t}$はbar$t=1,\ldots,T$におけるopen時の商品$i=1,\ldots,I$の価格を示す。取引開始時点の価格で、そのbarの価格動向の基準点として機能する。
- $p_{i,t}$はbar$t=1,\ldots,T$におけるclose時の商品$i=1,\ldots,I$の源系列である。取引終了時の価格で、そのbarの市場の最終的な評価を示す。
- $\varphi_{i,t}$はbar$t=1,\ldots,T$における商品$i$への資金の流入または流出を表す。これには購入、売却、リバランスのための資金移動が含まれる。
- $v_{i,t}$はbar$t=1,\ldots,T$における商品$i=1,\ldots,I$の出来高である。

なお、全ての商品$i=1,\ldots, I$はbar$t=1,\ldots,T$で取引可能であるとする。
取引可能というのは、言い換えれば、いくつかの商品が$[t-1, t]$の間で取引が不可能であったとしてもピンポイントの点$t, t-1$では取引可能であるとする。

\$1を投資した際の時系列$\set{K_t}$をbar$B\sub \set{1,\ldots, T}$においてアロケーションベクトル$\omega_t$でリバランス(重み付けられること)によって特徴付けられる先物バスケットに対して以下のように定義する。

$$
\begin{aligned}

K_t &= K_{t-1} + \sum_{i=1}^I h_{i,t-1}\varphi_{i,t}\delta_{i,t} \\
h_{i,t} &= 
\begin{cases}
\frac{\omega_{i,t}K_t}{o_{i,t+1}\varphi_{i,t}\sum_{i=1}^I|\omega_{i,t}|} & \text{if}\ t \in B \\

h_{i,t-1} & \text{otherwise}
\end{cases} \\

\delta_{i,t} &=
\begin{cases}
p_{i,t}-o_{i,t} & \text{if}\ t-1 \in B \\
\Delta p_{i,t} & \text{otherwise}
\end{cases}
\end{aligned}
$$

ここで、投資価値(AUM)の初期値を$K_0=1$とする。
- $h_{i,t}$は時点$t$での資産$i$の保有量である。ETFトリックを使用する際、異なる資産間でバランスをとるために各資産の保有量を調整する必要がある。ここで、$\omega_{i,t}$は時点$t$での資産$i$のウェイトを表すが、これは戦略に基づいて資産に割り当てられrう相対的な重要度や比率を表す。$h_{i,t}$には$\omega_{i,t}/(\sum_{i=1}^I|\omega_{i,t}|)$が含まれており、全資産のウェイトの合計が1になるように正規化されており、レバレッジが特定のレベルに制限されている場合に重要である。これにより、たとえば、ある資産のパフォーマンスが良いために市場価値が上昇し、ポートフォリオ内で過大評価されるリスクを防ぐために他の資産とのバランスを取る必要がある。正規化により、各資産への投資比率を戦略に基づいて適切に調整し、リスク分散を図ることができる。
- $\delta_{i,t}$は時点$t$での資産$i$の価格変動を表す。この値は資産価格の変動に基づいて、戦略のPnLを計算するために使われる。
- $K_t$これは全体の資本またはポートフォリオの合計値を表す。この値は時点$t$での全資産の総価値を表し、ポートフォリオのパフォーマンスを評価するために用いられる。

さて、この式の意味がわからないかもしれないが、

$$
\begin{aligned}
K_t &= K_{t-1} + \sum_{i=1}^I t\text{期での合計損益} \\
    &= K_{t-1} + \sum_{i=1}^I \{t-1\text{期での株数}\}\times \{\text{各株からの利益率}\} \\
    &= K_{t-1} + \sum_{i=1}^I \{t-1\text{期での株数}\} \\
    &\times \{\text{為替レート}\} \times \{\text{株の価格変動}\}
\end{aligned}
$$


### PCAによるウェイト
自分がどれだけのリスク(標準偏差)$\sigma$を許容するか、どのようなリスク分布$R=\set{R_i}_ {i=1,\ldots,I}$を望むかによって、各証券に割り当てるウェイト$\set{\omega_i}_ {i=1,\ldots,I}$を逐次的に変更することができる。そこで、$I$種類の証券の分散共分散行列を$V$とし、市場から得られる分散共分散行列$V$と自身が望むリスク分布$R$とリスク$\sigma$から、各証券に割り当てるウェイト$\omega$の関係を調べる。

なお、この分散共分散行列$V$はiidガウス過程により生成されたものとする。

Vを固有値分解し, $\Lambda = W^{T}VW$とする。なお、$\Lambda$の対角成分は降順に並べられるものとする。
この場合のポートフォリとのリスクは
$$
\begin{aligned}
\sigma^2 &= \omega^{T}V\omega = \omega^{T}W^{T}\Lambda W\omega \\
&=\beta^{T}\Lambda\beta = \sum_{i=1}^I\lambda_i\beta_i^2
\end{aligned}
$$
となる。
ここで、$\beta = W\omega$とする。
また、$i$番目の証券のリスク寄与率は
$$
R_i = \frac{\lambda_i\beta_i^2}{\sum_{i=1}^I\lambda_i\beta_i^2} = \frac{\lambda_i\beta_i^2}{\sigma^2}
$$
のようにして表現される。
また$R = \set{R_i}$とし
$$
R\bm{1} = 1
$$
となることに注意する。
さて、
$$
\begin{aligned}
{\beta_i}^2 &= \frac{R_i\sigma^2}{\lambda_i} \\
\beta_i &= \sqrt{\frac{R_i\sigma^2}{\lambda_i}}
\end{aligned}
$$
となる。
よって、$\beta = \set{\beta_i}$であり、$\beta = W\omega$から
$$
\begin{aligned}
\omega &= W^{-1}\beta \\
&= W^T\beta
\end{aligned}
$$
となる。
ここで、ウェイトはリスク分散によらずリスクと比例の関係であることがわかる。

### 特徴量サンプリング
データをtime, ticksやvolume, dollarなどにサンプリングすることは前回に行った。
それらは全て良い統計的特徴をもたらす時系列データを取得するためであり、機械学習の学習時の入力として扱うためにはデータの量が多い。
サンプリングで最も簡単な方法は一定の間隔でサンプリングする方法である。
しかし、以下ではイベントベースのサンプリング方法について説明する。
使い方としては、イベントベースでサンプリングした点からbarの採取を行う。

#### CUSUMフィルタ
CUSUMフィルタは測定した値の平均値が目標値からどれだけ離れているかを検知するためのフィルタである。(異常検知に使える?)
これもimbalanceと同じような考えで、ある累積値を超えたらサンプリングするという方法である。
累積値を
$$
\begin{aligned}
S_t &= \max\set{0, S_{t-1} + y_t - \mu} \\
\mu &= \mathbb{E}_ {t-1}[y_t]
\end{aligned}
$$
この累積値が適当な閾値$h$を超えたらサンプリングするという方法である。
また、これは上昇方向、つまり$y_t$が上がり調子の場合を検知するが、下がり調子、下落方向を検知する方法もある。
$$
\begin{aligned}
S_ t^+ &= \max\set{0, S^+_ {t-1} + y_t - \mu} \\
S_ t^- &= \min\set{0, S^-_ {t-1} + y_t - \mu} \\
S_0^+ &= S_0^- = 0 \\
\mu &= \mathbb{E}_ {t-1}[y_t] \\
S_t &= \max\set{S_t^+, S_t^-}
\end{aligned}
$$
やってることはCUSUMと同じである。これを対象CUSUMと呼ぶ。

