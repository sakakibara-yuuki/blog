---
title: 'Reactのコンポーネントのメモリ'
author: "sakakibara"
description: 'Lorem ipsum dolor sit amet'
heroImage: '/blog-placeholder-3.jpg'
pubDate: 2024-09-29
tags: ["frontend", "react"]
---

# Introduction
stateとは何か, どのように使われるのかを解説する.

## Contents
<!-- ## hooks -->
<!-- `use`で始まる関数はhooksと呼ばれる. -->
<!-- hooksはレンダー時にのみ呼び出すことができる特別な関数であり, Reactの機能に接続(hook into)する. -->

## state
ユーザーが画面を操作することによって, 画面が変化することがある.
例えば, "購入"をクリックすると, 買い物かごが"+1"になる.
入力フォームに文字を入力すると, その文字が画面に表示される.

このように, コンポーネントは買い物かごの状態, 現在の入力値, などを覚えておく必要がある.

このように, **コンポーネント固有のメモリをstateという**.

なぜ, このような個別のメモリが必要なのか.
なぜ, 通常のローカル変数は固有のメモリとしてつかえないのか.

理由は2つある.
1. レンダーによってコンポーネントが再生性されるため, ローカル変数は毎回初期化されてしまう.
1. ローカル変数の値が変わっても, 画面が更新されない.

そこで, stateのようなコンポーネント固有のメモリが必要になる.
コンポーネント固有のメモリは以下の2つの性質を満たす.

1. レンダー間で値が保持される.
1. 新しい値がセットされると, 画面が更新される.

そして, `useState`によってstateを実現する.

`useState`にはいくつか興味深い仕様がある.

まず, 同じコンポーネントを2回レンダーした場合, それぞれのレンダーで異なるstateを持つことができる.
つまり, レンダー間でstateは独立なのだ.

また, stateをセットしても既にあるstate変数は変更されず, 再レンダーのトリガーが引かれる.
これにより, イベントによってUIを変更するためにはstateを更新する必要がある.

ところで, レンダーの結果返されるJSXはその時点のUIの"スナップショット"を表す. つまり, その中で使用される**props, イベントハンドラ, ローカル変数はレンダー時のstateを用いて計算される.**

stateは通常のローカル変数とは異なり, Reactの中で存続している. 関数の外部で存続し続けている.

そして, Reactがとあるコンポーネントをレンダーする際, そのコンポーネントに対するstateのスナップショットがReactから提供される.
**そのコンポーネントはJSXを返し, その中で使われているstateはそのレンダー時のstateである.**

この仕様が如実に現れた例がある.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);
  return (
    <>
      <h1>{ number }</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
        }}
      >+3</button>
    </>
  )
}
```
想像してみよう. buttonを1度クリックした際, `h1`タグの表示は何になるだろうか.

答えは, 1になる.

`setNumber`が3回呼ばれているので, 1度クリックするたびに　, 3づつインクリメントされると思うかもしれないが, 実際には1度クリックするたびに, 1づつインクリメントされる.

なぜならば, コンポーネントに使われるstateはそのレンダー時のstateであるからである. 言い換えれば, **stateをセットしても, それが本当に変更されるのは次回のレンダー**だからである.

その動作をわかりやすくするために, レンダー時のstateの値を実際に当てはめて先程のコンポーネントを表現すると

```jsx
<button onClick={() => {
  setNumber(0 + 1);
  setNumber(0 + 1);
  setNumber(0 + 1);
}}>+3</button>
```
のようになる.
numberには前回のレンダー時(初回レンダー時)のstateが使われるので0になる.
一度クリックすると,
```jsx
<button onClick={() => {
  setNumber(1 + 1);
  setNumber(1 + 1);
  setNumber(1 + 1);
}}>+3</button>
```
のようになる.

このように, コンポーネントのstateはレンダー時のstateである.

## stateはまとめて更新される
先程の例では, `setNumber`が3回呼ばれていたが, コンポーネントのstateはレンダー時のstateが使われるため, 1度クリックするたびに1づつインクリメントされた.
実は, 1クリックずつに3づつインクリメントされなかった要因として, 他の要因がある.

それは, **イベントハンドラ内の全てのコードが実行されるまで, Reactはstateの更新処理を待機する**という仕様である. このため, `seNumber()`の呼び出しがすべて終わった後に再レンダーが行われる.

これにより, 再レンダーを引き起こすトリガーを過剰に引かなくて済むため, パフォーマンスが向上する.
このような動作はバッチ処理とも呼ばれる.

## レンダー前にstateを更新する
一般的な使い方ではないが, 次のれんだー前にstateを複数回更新することができる.
それは`setNumber(number + 1)`のように, 現在のstateを使ってstateを更新するのではなく, 関数を使ってstateを更新することである.

```jsx
setNumber(number => number + 1);
```
これを用いると,
```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);
  return (
    <>
      <h1>{ number }</h1>
      <button onClick={() => {
        setNumber(n => n + 1);
        setNumber(n => n + 1);
        setNumber(n => n + 1);
        }}
      >+3</button>
    </>
  )
}
```
これは3つづつインクリメントされる.
`n => n + 1`のような関数を**更新関数**と呼ぶ.
この動作について詳しく見ていく.

まず, 更新関数をsetterに渡すと,
1. Reactは更新関数をキューに入れて, イベントハンドラ内の全てのコードが実行された後に実行する.
2. 次のレンダー中に, Reactはキューにある更新関数を実行し, 最後に更新されたstateを返す.

まず, Reactは更新関数をキューに追加する.
**次のレンダー時, Reactはキューを処理する.**

|キュー内の更新関数 | n | 最後に更新されたstate |
|---|---|---|
|`n => n + 1` | `0` | `0 + 1 = 1` |
|`n => n + 1` | `1` | `1 + 1 = 2` |
|`n => n + 1` | `2` | `2 + 1 = 3` |

`3`を最終結果としてstateにセットする.

では, 更新関数と通常のstate変数の合わせ技として次のような例を考える.
```jsx
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
```
この場合, どのような動作になるだろうか.

この場合, `setNumber(number + 5)`は`setNumber(0 + 5)`となり, Reactはキューに"5"を追加する.
次に, `setNumber(n => n + 1)`の更新関数`n => n + 1`がキューに追加される.

次のレンダー時, Reactはキューを処理する.
|キュー内の更新関数 | n | 最後に更新されたstate |
|---|---|---|
|`5`に置き換える | `0` | `5` |
|`n => n + 1` | `5` | `5 + 1 = 6` |

`6`を最終結果としてstateにセットする.

ここで気づいたかもしれないが, `setNumber(number + 5)`は`setNumber(n => n + 5)`としても同じ結果になる.

更新関数の使用上の注意点として, 更新関数は純関数である必要があるということ.
また, 命名規則として更新関数の引数には対応するstate変数の頭文字を使うことが推奨される.
